---
title: "Other_CCA"
output:
  html_document:
    df_print: paged
date: "2023-03-21"
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(lava)
library(matlab)
library(plyr)
library(ggplot2)
library(plotly)
library(RGCCA)

```

```{r evaluation}

FS_MCC = function(U,V,W,len){
  library(caret)
  Label = c(rep(1,2),rep(0,len-2))
  tp = 0
  tn = 0
  fn = 0
  fp = 0
  
  pred = as.numeric(abs(U)>mean(abs(U)))
  C = confusionMatrix(as.factor(pred), reference = as.factor(Label))
  
  tp = tp + C$table[4]
  tn = tn + C$table[1]
  fn = fn + C$table[3]
  fp = fp + C$table[2]
  
  pred = as.numeric(abs(V)>mean(abs(V)))
  C = confusionMatrix(as.factor(pred), reference = as.factor(Label))
  
  tp = tp + C$table[4]
  tn = tn + C$table[1]
  fn = fn + C$table[3]
  fp = fp + C$table[2]
  
  pred = as.numeric(abs(W)>mean(abs(W)))
  C = confusionMatrix(as.factor(pred), reference = as.factor(Label))
  
  tp = tp + C$table[4]
  tn = tn + C$table[1]
  fn = fn + C$table[3]
  fp = fp + C$table[2]
  acc = (tp + tn) / (tp+tn+fp+fn)
  
  precision = tp/(tp+fp)
  recall = tp/(tp+fn)
  f1 = 2*precision*recall/(precision+recall)
  mcc = (tp*tn-fp*fn)/sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))
  
  return(list(Accruacy = acc,F1 = f1,MCC = mcc))
}

```

gendata3
```{r gendata3}
create_synthData_new <- function(v=5, N=400, mode=1, P=100) {
  # Setting random seed

  
  # Generating E1, E2, and E3
  E1 <- matrix(rnorm(N * P, mean=0, sd=sqrt(0.2)), nrow=N, ncol=P)
  E2 <- matrix(rnorm(N * P, mean=0, sd=sqrt(0.2)), nrow=N, ncol=P)
  E3 <- matrix(rnorm(N * P, mean=0, sd=sqrt(0.2)), nrow=N, ncol=P)
  
  if (mode == 1) {
    # Set the dimension of the multivariate normal distribution
    dimension <- 3  # Change this to the desired dimension
    
    # Generate random data from a multivariate normal distribution with mean=0 and covariance=identity matrix
    data <- MASS::mvrnorm(N, mu = rep(0, dimension), Sigma = diag(dimension))
    
    # Desired correlation matrix
    desired_corr1 <- 0.7
    desired_corr2 <- 0.0
    
    # Generate the covariance matrix from the desired correlation
    cov_matrix <- matrix(c(1, desired_corr1, desired_corr1,
                           desired_corr1, 1, desired_corr2,
                           desired_corr1, desired_corr2, 1), nrow = dimension, byrow = TRUE)
    
    # Compute the Cholesky decomposition of the covariance matrix
    L <- chol(cov_matrix)
    
    # Transform the data to have the desired covariance matrix
    data <- data %*% t(L)
    
    # Verify the covariance matrix and correlation
    #print("Covariance matrix:")
    #print(cov(data))
    #print("Correlation matrix:")
    #print(cor(data))
    
    # Define the dimensions of the vectors
    w1_dim <- P
    w2_dim <- P
    w3_dim <- P
    
    # Define the number of nonzero elements
    nonzero_elements <- v
    
    # Generate nonzero elements from a uniform distribution
    nonzero_values <- c(runif(nonzero_elements, min=-1, max=-0.9), runif(nonzero_elements, min=0.9, max=1))
    nonzero_values <- sample(nonzero_values)
    
    # Initialize w1, w2, and w3 as zero vectors
    w1 <- rep(0, w1_dim)
    w2 <- rep(0, w2_dim)
    w3 <- rep(0, w3_dim)
    
    # Assign nonzero values to the first 75 elements of w1, w2, and w3
    w1[1:nonzero_elements] <- nonzero_values[1:nonzero_elements]
    w2[1:nonzero_elements] <- nonzero_values[1:nonzero_elements]
    w3[1:nonzero_elements] <- nonzero_values[1:nonzero_elements]
    
    # Shuffle the vectors to ensure randomness
    w1 <- sample(w1)
    w2 <- sample(w2)
    w3 <- sample(w3)
    
    V1 <- data[,1] %*% t(w1) + E1
    V2 <- data[,2] %*% t(w2) + E2
    V3 <- data[,3] %*% t(w3) + E3
  } else if (mode == 2) {
    # Create a random set
    V1 <- E1
    V2 <- E2
    V3 <- E3
    
    # Generate 10 random seeds
    random_seeds <- sample.int(2^16 - 1, v, replace=TRUE)
    
    for (i in 1:length(random_seeds)) {
      set.seed(random_seeds[i])
      samples <- rnorm(N)
      v1 <- samples * (2 * pi)
      v2 <- cos(v1)
      v3 <- v1 * cos(v1)
      scaled_v1 <- ((v1 - mean(v1)) / sd(v1)) * 2
      scaled_v2 <- ((v2 - mean(v2)) / sd(v2)) * 2
      scaled_v3 <- ((v3 - mean(v3)) / sd(v3)) * 2
      
      V1[,i] <- scaled_v1 + V1[,i]
      V2[,i] <- scaled_v2 + V2[,i]
      V3[,i] <- scaled_v3 + V3[,i]
    }
  }
  
  views <- list(V1, V2, V3)
  #print("------------------")
  return(views)
}

# Usage example
result <- create_synthData_new()

```

```{r gendata_loop}
gendatan = function(i,n,p,q,r,type){
  
  X = matrix(rnorm(n*p,mean=0,sd=1),nrow=n,ncol=p)
  Y = matrix(rnorm(n*q,mean=0,sd=1),nrow=n,ncol=q)
  Z = matrix(rnorm(n*q,mean=0,sd=1),nrow=n,ncol=r)
  
  if(i == 2){
    if(type ==1){
    Y[,1] = X[,1] + X[,2] - Y[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = 2*(X[,1] + X[,2]) - Z[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  }else if(type ==2 ){
    Y[,1] = 1 * sin(1 *matrix(X[,1] + X[,2],nrow=nrow(X),ncol=1)) - Y[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = 1 * cos(1 *matrix(Y[,1] + Y[,2],nrow=nrow(Y),ncol=1))^2 - Z[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  } else if(type ==3){
    Y[,1] = (X[,1] + X[,2])^3 - Y[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = (X[,1] + X[,2])^2 - Z[,2] + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  } else if(type ==4){
    Y[,1] = cos(X[,1]+X[,2]) -Y[,2]
    Z[,1] = sin(X[,1]+X[,2]) -Z[,2]
  }else if(type ==5){
    
    Z[,1] = sqrt(4-(X[,1]+X[,2])^2 - (Y[,1]+Y[,2])^2) -Z[,2]
  }
  }else{
    if(type ==1){
    Y[,1] = rowSums(X[,1:i]) - rowSums(Y[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = 2*rowSums(X[,1:i]) - rowSums(Z[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  }else if(type ==2 ){
    Y[,1] = 1 * cos(1 *matrix(rowSums(X[,1:i]),nrow=nrow(X),ncol=1))^2 - rowSums(Y[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = 1 * sin(1 *matrix(rowSums(X[,1:i]),nrow=nrow(Y),ncol=1)) - rowSums(Z[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  } else if(type ==3){
    Y[,1] = 20 / (rowSums(X[,1:i])) - rowSums(Y[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
    Z[,1] = 20 / (rowSums(X[,1:i])) - rowSums(Z[,2:i]) + matrix(rnorm(n,mean=0,sd=0.05),nrow=n,ncol=1)
  } else if(type ==4){
    Y[,1] = cos(rowSums(X[,1:i])) - rowSums(Y[,2:i])
    Z[,1] = sin(rowSums(X[,1:i])) - rowSums(Y[,2:i])
  }else if(type ==5){
    
    Z[,1] = sqrt(30-(X[,1]+X[,2])^2 - (Y[,1]+Y[,2])^2) -Z[,2]
  }
  }
  
  
  return(list(X=X,Y=Y,Z=Z)) 
}

Data1 = gendatan(4,300,20,20,20,1)

Data1$X

```

```{r}
X = read.table("C:/Users/Programer/Documents/GitHub/SGCCA_HSIC/SNGCCA/RealData/Exp664.txt", header = F, sep = " ")
Y = read.table("C:/Users/Programer/Documents/GitHub/SGCCA_HSIC/SNGCCA/RealData/Meth664.txt", header = F, sep = " ")
Z =  read.table("C:/Users/Programer/Documents/GitHub/SGCCA_HSIC/SNGCCA/RealData/miRNA664.txt", header = F, sep = " ")

Data_real = list(X = t(X), Y = t(Y), Z = t(Z))
result = rgcca(Data_real, connection = 1 - diag(length(Data_real)), tau = rep(1, length(Data_real)), ncomp = rep(1,
length(Data_real)), scheme = "centroid", init = "svd",
bias = TRUE, tol = .Machine$double.eps, verbose = FALSE)

u=result$a[[1]]
v=result$a[[2]]
w=result$a[[3]]

write.csv(u,'SGCCA_u.csv')
write.csv(v,'SGCCA_v.csv')
write.csv(w,'SGCCA_w.csv')
count = 0
for(i in 1:length(u)){
  # print(u[i])
  
  if (u[i] > 1/2642){
    count =count + 1
    #print(i)
  }
}
print(count)
count = 0
for(i in 1:length(v)){
  # print(u[i])
  if (v[i] > 1/ length(v)){
    #print(i)
    count =count + 1
  }
}
print(count)
count = 0
for(i in 1:length(w)){
  # print(u[i])
  if (w[i] > 1/length(w)){
    #print(i)
    count =count + 1
  }
}

```

```{r cluster}
library(cluster)
library(fpc)

# 假设你的聚类结果存储在变量 cluster_result 中

# 计算 Silhouette Score
silhouette_score <- silhouette(cluster_result$cluster, dist(cluster_result$distance_matrix))

# 计算 DB Score
db_score <- cluster.stats(cluster_result$cluster, cluster_result$distance_matrix)$DB

# 计算 CH Score
ch_score <- cluster.stats(cluster_result$cluster, cluster_result$distance_matrix)$ch

# 输出结果
print(silhouette_score)
print(db_score)
print(ch_score)

```

### Linear GCCA
```{r}
## default N = 400 Scenario 1
Data1 = gendata3(400,20,20,20,1)

result = rgcca(Data1, connection = 1 - diag(length(Data1)), tau = rep(1, length(Data1)), ncomp = rep(1,
length(Data1)), scheme = "centroid", init = "svd",
bias = TRUE, tol = .Machine$double.eps, verbose = FALSE)
trans=result$Y
u=result$a[[1]]
v=result$a[[2]]
w=result$a[[3]]

r.1 = FS_MCC(u,v,w)
print(r.1$F1)


x_new=array(trans[[1]])
y_new=array(trans[[2]])
z_new=array(trans[[3]])
x_ground = Data1$X[,1] + Data1$X[,2]
y_ground = Data1$Y[,1] + Data1$Y[,2]
z_ground = Data1$Z[,1] + Data1$Z[,2]


data <- data.frame(x_new=x_new,y_new=y_new,z_new=z_new,x_ground=x_ground,y_ground=y_ground,z_ground=z_ground)
px = ggplot(data) +
  geom_point(aes(x = x_new ,y =y_new),alpha = .5) +
  geom_smooth(aes(x = x_ground ,y =y_ground),alpha = .5) +
  scale_colour_brewer(palette = "Set1")
ggsave(px,filename = "r1_x.png")
px
py = ggplot(data) +
  geom_point(aes(x = x_new ,y =z_new),alpha = .5) +
  geom_smooth(aes(x = x_ground ,y =z_ground),alpha = .5) +
  scale_colour_brewer(palette = "Set1")
ggsave(py,filename = "r1_y.png")
py
pz = ggplot(data) +
  geom_point(aes(x = y_new ,y =z_new),alpha = .5) +
  geom_smooth(aes(x = y_ground ,y =z_ground),alpha = .5) +
  scale_colour_brewer(palette = "Set1")
ggsave(pz,filename = "r1_z.png")
pz

data.3d = data.frame(rbind(cbind(as.matrix(data[,1:3]),type = "new"),cbind(as.matrix(data[,4:6]),type = "ground")))

plot_ly(data.3d,x=~x_new, y=~y_new, z=~z_new, type="scatter3d", mode="markers",color=~data.3d$type)


DATA_FINAL = data.frame(as.matrix())
ACC = rep(0,100)
f1_score = rep(0,100)
MCC = rep(0,100)
for( i in 1:100){
  if(i %% 50 == 0){print(i)}
  Data1 = gendata3(400,20,20,20,1)
  result = rgcca(Data1, connection = 1 - diag(length(Data1)), tau = rep(1, length(Data1)), ncomp = rep(1,
  length(Data1)), scheme = "centroid", init = "svd",
  bias = TRUE, tol = .Machine$double.eps, verbose = FALSE)
  trans=result$Y
  u=result$a[[1]]
  v=result$a[[2]]
  w=result$a[[3]]
  
  r.1 = FS_MCC(u,v,w)

  ACC[i] = r.1$Accruacy
  f1_score[i] = r.1$F1
  MCC[i] = r.1$MCC
}
mean(ACC)
sd(ACC, na.rm = FALSE)

mean(f1_score)
sd(f1_score, na.rm = FALSE)

mean(MCC)
sd(MCC, na.rm = FALSE)

```


### Linear RGCCA
```{r}
n = 100
p = 200
r = 100
v = 5

cor_matrix <- matrix(c(1, 0.7, 0.7,
                        0.7, 1, 0,
                        0.7, 0, 1), 
                     nrow = 3, 
                     ncol = 3, 
                     byrow = TRUE)
RGCCA_u1 <- array(NA, dim = c(r, p))
RGCCA_u2 <- array(NA, dim = c(r, p))
RGCCA_u3 <- array(NA, dim = c(r, p))
SGCCA_u1 <- array(NA, dim = c(r, p))
SGCCA_u2 <- array(NA, dim = c(r, p))
SGCCA_u3 <- array(NA, dim = c(r, p))

for( i in 1:100){
  if(i %% 10 == 0){print(i)}
  Data1 = create_synthData_new(v,n,2,p)
  res1 = rgcca(Data1)
  RGCCA_u1[i,] = res1$a[[1]]
  RGCCA_u2[i,] = res1$a[[2]]
  RGCCA_u3[i,] = res1$a[[3]]
  
  res2 = rgcca(Data1, connection = 1 - cor_matrix, tau = rep(1, length(Data1)), ncomp = rep(1,
  length(Data1)), scheme = "centroid", init = "svd", bias = TRUE, tol = .Machine$double.eps, verbose = FALSE)
  SGCCA_u1[i,] = res2$a[[1]]
  SGCCA_u2[i,] = res2$a[[2]]
  SGCCA_u3[i,] = res2$a[[3]]
}

write.csv(RGCCA_u1,"rgcca_u1.csv")
write.csv(RGCCA_u2,"rgcca_u2.csv")
write.csv(RGCCA_u3,"rgcca_u3.csv")
write.csv(SGCCA_u1,"sgcca_u1.csv")
write.csv(SGCCA_u2,"sgcca_u2.csv")
write.csv(SGCCA_u3,"sgcca_u3.csv")
```
